虚函数表是什么

#### 简要回答
虚函数表(VTable)是C++实现**运行时多态性**的核心机制，它是一个**存储类虚函数地址**的**指针数组**。**每个包含虚函数的类都有一个虚函数表**，对象通过**隐藏的vptr指针**访问该表来实现**动态绑定**。

虚函数表就像是一张函数地址清单，当类里有虚函数时，编译器会自动创建这个表。

#### 详细回答
虚函数表是C++实现动态多态的关键数据结构，具有以下特点：

每个包含虚函数的类都有一个虚函数表

表中按声明顺序存储该类所有虚函数的函数指针

**派生类**会**继承基类的虚函数表**，并**重写覆盖的虚函数指针**

每个对象实例包含一个**隐藏的vptr指针**指向**其类的虚函数表**

调用虚函数时通过**vptr间接寻址**，实现**运行时多态**

虚函数表**在编译期构造，运行期使用，是实现"一个接口，多种实现"的核心机制**。


#### 代码详解
```cpp
#include <iostream>

class Base {
public:
    virtual void func1() { std::cout << "Base::func1" << std::endl; }
    virtual void func2() { std::cout << "Base::func2" << std::endl; }
    void func3() { std::cout << "Base::func3" << std::endl; }
};

class Derived : public Base {
public:
    void func1() override { std::cout << "Derived::func1" << std::endl; }
    virtual void func4() { std::cout << "Derived::func4" << std::endl; }
};

int main() {
    Base b;
    Derived d;
    
    Base* pb = &d;
    pb->func1();  // 输出 Derived::func1 - 动态绑定
    pb->func2();  // 输出 Base::func2
    // pb->func4(); // 错误: Base没有func4成员
    
    return 0;
}
```
以上代码Base类的虚函数表包含两个条目：&Base::func1和&Base::func2，其中func3不是虚函数

Derived类的虚函数表：

它会继承Base的虚函数表，**覆盖func1为&Derived::func1**

添加新条目&Derived::func4

func3是非虚函数，不进入虚函数表

通过基类指针调用虚函数时，通过对象的vptr找到Derived的虚函数表，再调用对应的函数
#### 知识拓展
- 知识图解
![image](https://file1.kamacoder.com/i/bagu/1.png)

- 面试官可能追问

虚函数表在内存中的什么位置？

答：通常位于程序的只读数据段(.rodata)，由编译器在编译期生成

构造函数中能调用虚函数吗？会发生什么？

可以调用，但会静态绑定到当前类的实现，因为派生类构造时vptr还未指向派生类的虚函数表

虚函数与模板多态的区别？

虚函数是运行时多态，模板是编译时多态；虚函数有运行时开销但更灵活